<!--
To change this template, choose Tools | Templates
and open the template in the editor.
-->
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Ellis's physics three.js demo</title>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	</head>
	<body>
	<canvas id="c" width="640" height="640"></canvas>
	<style type="text/css">
		* {
			margin:0;
			padding:0;
		}
		body {
			overflow: hidden;
			font-family: Monospace;
		}
	</style>
		<script src="lib/cannon.js"></script>
		<script src="lib/three.js"></script>
		<script src="lib/threejs/TrackballControls.js"></script>
		<script type="text/javascript">
			var size = 1;
			var dampling = 0.01;
			var mass = 10;
			var sphereShape;
			var ballMaterial;
			var bodies = [];
			var world;
			var N = 1000;
			var controls;
			var bShowBoundary = false;
			var camera;

			init();
			animate();

			function init() {

				world = new CANNON.World();
				world.broadphase = new CANNON.NaiveBroadphase();
				world.gravity.set(0,-10,0);
				world.solver.tolerance = 0.001;
				
				var stone = new CANNON.Material('stone');
				var stone_stone = new CANNON.ContactMaterial(stone, stone, {
				  friction: 0.3,
				  restitution: 0.2
				});
				world.addContactMaterial(stone_stone);

				// ground plane
				groundMaterial = new CANNON.Material();
				var groundShape = new CANNON.Plane();
				var groundBody = new CANNON.Body( { mass: 0, material: groundMaterial } );
				groundBody.addShape(groundShape);
				groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI/2);
				groundBody.position.set(0, -20, 0);
				world.addBody(groundBody);

				// plane -x
				var planeShapeXmin = new CANNON.Plane();
				var planeXmin = new CANNON.Body({ mass: 0, material: stone });
				planeXmin.addShape(planeShapeXmin);
				planeXmin.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI/2);
				planeXmin.position.set(-30, 0, 0);
				world.addBody(planeXmin);

				// Plane +x
				var planeShapeXmax = new CANNON.Plane();
				var planeXmax = new CANNON.Body({ mass: 0, material: stone });
				planeXmax.addShape(planeShapeXmax);
				planeXmax.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI/2);
				planeXmax.position.set(30, 0, 0);
				world.addBody(planeXmax);

				// Plane +y
				var planeShapeYmax = new CANNON.Plane();
				var planeYmax = new CANNON.Body({ mass: 0,  material: stone });
				planeYmax.addShape(planeShapeYmax);
				planeYmax.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI/2);
				planeYmax.position.set(0, 40, 0);
				world.addBody(planeYmax);
				
				// Plane -z
				var planeShapeZmin = new CANNON.Plane();
				var planeZmin = new CANNON.Body({ mass: 0, material: stone });
				planeZmin.addShape(planeShapeZmin);
				planeZmin.position.set(0, 0, -20);
				world.addBody(planeZmin);

				// Plane +z
				var planeShapeZmax = new CANNON.Plane();
				var planeZmax = new CANNON.Body({ mass: 0, material: stone });
				planeZmax.addShape(planeShapeZmax);
				planeZmax.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0),-Math.PI);
				planeZmax.position.set(0, 0, 20);
				world.addBody(planeZmax);

				// // Shape on plane
				sphereShape = new CANNON.Sphere(size);
				ballMaterial = new CANNON.Material();

				// Init camera controller
				// Controls
				camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.5, 10000);
				camera.target = new THREE.Vector3(0, 0, 0);
				camera.position.set(0, 30, 170);
				controls = new THREE.TrackballControls( camera );
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;

				generateBalls();
				// Create contact material behaviour
				var ballGroundContact = new CANNON.ContactMaterial( groundMaterial, ballMaterial, { friction: 0.0, restitution: 9 } );

				world.addContactMaterial(ballGroundContact);
				initWorker();
			}

			var worker;

			function initWorker() {
				var canvas = document.getElementById('c');
				canvas.width = window.innerWidth;
				canvas.height = window.innerHeight;
				var proxy = canvas.transferControlToOffscreen();   // new interface added by offscreencanvas.

				if ( window.Worker ) { 

					worker = new Worker("js/gl_worker_three.js");
					worker.onmessage = function( evt ) {
						console.log('Message received from worker ' + evt.data );
					};

					worker.postMessage( { test: 'webgl_offscreen', canvas: proxy, ballNums: N, bShowBoundary: bShowBoundary }, [proxy]);
				}
			}

			function updateWorker() {
				// It have to new them in loops. Why?
				var positions = new Float32Array(N*3);	
				var quaternions = new Float32Array(N*4);
				var cameraState = new Float32Array(7);

				cameraState[0] = camera.position.x;
				cameraState[1] = camera.position.y;
				cameraState[2] = camera.position.z;
				cameraState[3] = camera.quaternion.x;
				cameraState[4] = camera.quaternion.y;
				cameraState[5] = camera.quaternion.z;
				cameraState[6] = camera.quaternion.w;

				var lens = bodies.length;

				for ( var i = 0; i < lens; ++i ) {
					var b = bodies[i];
					var p = b.position;
					var q = b.quaternion;

					positions[3 * i + 0] = p.x;
					positions[3 * i + 1] = p.y;
					positions[3 * i + 2] = p.z;

					quaternions[4 * i + 0] = q.x;
					quaternions[4 * i + 1] = q.y;
					quaternions[4 * i + 2] = q.z;
					quaternions[4 * i + 3] = q.w; 
				}

				worker.postMessage( { cameraState: cameraState, positions: positions, quaternions: quaternions }, [cameraState.buffer, positions.buffer, quaternions.buffer]);
			}

			function animate( timestamp ) {
				var dt = 1/60;

				controls.update();

				world.step( dt ); // Update the phyics world.
				updateWorker();
				requestAnimationFrame( animate );
			}

			function generateBalls() {

				var radius = 1;
				var size = radius;

				for ( var i = 0; i < N; ++i ) {

					var ballBody = new CANNON.Body( {
						mass: mass,
						material: ballMaterial,
						position: new CANNON.Vec3( (Math.random() - 0.5) * 20, (Math.random() - 0.5) * size, Math.random() * 20 )
					});
				
					ballBody.addShape( sphereShape );
					ballBody.linearDampling = dampling;
					world.addBody( ballBody );
					bodies.push( ballBody );
				}
			}

			function shootBall() {

				var shootVelo = 15;
				var ballHeight = 10;
				var shootDirection = new THREE.Vector3();
				var projector = new THREE.Projector();

				shootDirection.set( 0,0,1 );
				camera = demo.getCamera();
				var mat = new CANNON.Material();
				projector.unprojectVector(shootDirection, camera);
				var sphereBody = new CANNON.Body( {
					mass: mass,
					material: mat,
					position: new CANNON.Vec3( 3 * size, size, ballHeight )
				});
				var mat_mat = new CANNON.ContactMaterial(mat, mat, {
				  friction: 0.3,
				  restitution: 5
				});
				var mat_ground = new CANNON.ContactMaterial(groundMaterial, mat, { friction: 0.0, restitution: 5 });
				demo.world.addContactMaterial(mat_ground);

				var ray = new THREE.Ray(camera.position, shootDirection.sub(camera.position).normalize() );
				shootDirection.x = ray.direction.x;
				shootDirection.y = ray.direction.y;
				shootDirection.z = ray.direction.z;

				sphereBody.velocity.set( shootDirection.x * shootVelo,
										shootDirection.y * shootVelo,
										shootDirection.z * shootVelo);

				var x = camera.position.x;
				var y = camera.position.y;
				var z = camera.position.z;

				// Move the ball outside the player sphere
				x += shootDirection.x * ( sphereShape.radius );
				y += shootDirection.y * ( sphereShape.radius );
				z += shootDirection.z * ( sphereShape.radius );
				sphereBody.position.set(x,y,z);

				sphereBody.addShape( sphereShape );
				sphereBody.linearDampling = dampling;
				demo.world.addBody( sphereBody );
				demo.addVisual( sphereBody );
			}

			window.addEventListener("click",function(e){

			   // shootBall();
			});
			
		</script>
	</body>
</html>
